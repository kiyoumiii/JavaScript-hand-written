<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 1.手写Object.create
        // 思路：将传入的对象作为原型
        // prototype 是函数对象的属性，用于为使用该函数创建的对象提供共享的属性和方法。
        function create(obj) {
            // 定义了一个空的构造函数 F。这个构造函数本身没有具体的逻辑，只是作为一个中间桥梁来实现对象的继承。
            function F() {}
            // 将构造函数 F 的原型（prototype）设置为传入的 obj 对象。
            F.prototype = obj
            // 使用 new 关键字调用构造函数 F 创建一个新对象。由于 F 的原型已经被设置为 obj，所以这个新对象会继承 obj 的所有属性和方法。
            return new F()
        }

        // 2.手写instanceof方法
        // instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
        // 实现步骤：
        //首先获取类型的原型
        //然后获得对象的原型
        //然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null

        function myInstanceof(left, right) {
            // left.prototype 不可用的原因
            //在 JavaScript 中，prototype 属性是函数对象特有的属性。只有函数对象才有 prototype 属性，普通对象没有这个属性。而在 myInstanceof 函数里，left 通常是一个普通对象实例，不是函数，所以 left 本身没有 prototype 属性。
            let proto = Object.getPrototypeOf(left);
            let prototype = right.prototype;
            // 判断构造函数的protoype是否在原型链上
            while(true) {
                if (!proto) return false;
                if (proto === prototype) return true;

                proto = Object.getPrototypeOf(proto);
                // 一直玄幻判断对象的原型是否等于类型的原型，直到对象原型为null，因为原型链最终为null
            }
        }

        // 3.手写new操作符
        // 在调用new的过程中会发生以上四件事情：
        // 首先创建了一个新对象
        // 设置原型，将对象的原型设置为函数的prototype对象
        // 让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）
        // 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

        function objectFactory() {
            let newObject = null;

            // shift 是 JavaScript 数组对象的一个内置方法，用于移除数组的第一个元素，并返回该元素。调用 shift 方法后，数组的长度会减 1，并且数组中剩余的元素会依次向前移动一个位置。
            // 这一行表示将 shift 方法内部的 this 指向 arguments 类数组对象，这样就可以让 arguments 借用数组的 shift 方法。
            // 这是因为，在 JavaScript 函数内部，arguments 是一个类数组对象，它包含了函数调用时传递的所有参数。arguments 具有索引和 length 属性，但它没有数组的方法（如 shift、push 等）。
            let constructor = Array.prototype.shift.call(arguments);
            let result = null;

            // 在 JavaScript 里，typeof 是一个操作符（而非方法），它的主要用途是返回一个表示数据类型的字符串
            if (typeof constructor !== 'function') {
                console.log('type error');
                return;
            }

            // 新建一个空对象，对象的原型为构造函数的prototype对象
            newObject = Object.create(constructor.prototype);

            // 将this指向新建对象，并执行函数
            // apply 是函数对象的一个内置方法，它允许你调用一个函数，并指定该函数内部 this 的值，同时可以以数组的形式传递参数给该函数。
            // func.apply(thisArg, [argsArray])
            // 构造函数内部的 this 会指向 newObject
            result = constructor.apply(newObject, arguments);

            // 判断返回对象，如果是对象或函数，就返回这个对象；如果返回的是基本数据类型或者没有返回值undefined则返回新创建的对象
            let flag = result && (typeof result === 'object' || typeof result == 'function');

            // 判断返回结果
            return flag ? result : newObject;

        }

        // 4.手写Promise
        // Promise 是 JavaScript 中用于处理异步操作的对象，它可以避免回调地狱问题
        // Promise 本质上是一个状态机，它有三种状态；而且状态一旦改变就不能再变。
        // Promise 对象内部维护了两个回调队列，分别用于存储成功回调函数和失败回调函数。当 Promise 的状态变为 fulfilled 时，会依次执行成功回调队列中的函数，并将成功的结果作为参数传递给这些函数；当状态变为 rejected 时，会依次执行失败回调队列中的函数，并将失败的原因作为参数传递给这些函数。

        // 回调地狱：在 JavaScript 里，传统处理异步操作的方式是使用回调函数。当有多个异步操作需要按顺序执行时，就需要在前一个异步操作的回调函数里嵌套调用下一个异步操作，以此类推。随着异步操作数量的增加，嵌套的层数也会不断增多，从而形成回调地狱。可读性差，可维护性低，错误处理困难。

        // JavaScript 是单线程的，这意味着同一时间只能执行一个任务。为了处理异步操作，JavaScript 引入了事件循环（Event Loop）机制。事件循环将任务分为两类：同步任务和异步任务。同步任务会在主线程上依次执行，而异步任务会被放入任务队列中，等待主线程上的同步任务执行完毕后再执行。

        const PENDING = 'pending';
        const RESOLVED = 'resolved';
        const REJECTED = 'rejected';

        function MyPromise(fn) {
            // 保存初始化状态
            var self = this;

            // 初始化状态
            this.state = PENDING;

            // 用于保存resolve或者rejected传入的值
            this.value = null;

            // 用于保存resolve的回调函数
            this.resolvedCallbacks = [];

            // 用于保存reject的回调函数
            this.rejectedCallbacks = [];

            // 状态转变为resolved的方法
            function resolve(value) {
                if (value instanceof MyPromise) {
                    return value.then(resolve, reject);
                }
            }

            // 保证代码的执行顺序为本轮事件循环的末尾
            setTimeout(() => {
                // 只有状态为pending时才能转变
                if (self.state === PENDING) {
                    // 修改状态
                    self.state = RESOLVED;

                    // 设置传入的值
                    self.value = value;

                    //执行回调函数
                    // 在 JavaScript 中，forEach 是数组对象的一个方法，用于对数组的每个元素执行一次提供的函数。
                    self.resolvedCallbacks.forEach(callback => {
                        callback(value);
                    });
                }
            }, 0);

        }

        // 状态转变为rejected方法
        function reject(value) {
            // 保证代码的执行顺序为本轮事件循环的末尾
            setTimeout(() => {
                // 只有状态为pending时才能改变
                if (self.state === PENDING) {
                    // 修改状态
                    self.state = REJECTED;
                    // 设置传入的值
                    self.value = value;
                    // 执行回调函数
                    self.rejectedCallbacks.forEach((callback => {
                        callback(value);
                    }))
                }
            }, 0);
        }

        // 将两个方法传入函数执行
        try {
            fn (resolve, reject);
        } catch(e) {
            // 遇到错误时，捕获错误，执行reject函数
            reject(e);
        }

        MyPromise.prototype.then = function(onResolved, onRejected) {
            // then 方法的主要功能是为 Promise 对象注册成功和失败的回调函数。

            onResolved = 
                typeof onResolved === 'function'
                    ? onResolved
                    : function(value) {
                        return value;
                    };

            onRejected = 
            typeof onRejected === 'function'
                    ? onRejected
                    : function(error) {
                        return error;
                    };

            // 如果是等待状态，则将函数加入对应列表中
            if (this.state === PENDING) {
                this.resolvedCallbacks.push(onResolved);
                this.rejectedCallbacks.push(onRejected);
            }

            // 如果状态已经凝固，则直接执行对应状态的函数
            if (this.state === RESOLVED) {
                onResolved(this.value);
            }

            if (this.state == REJECTED) {
                onRejected(this.value);
            }
        }


        // 6. 手写Promise.all
        // 它主要用于并行处理多个 Promise 对象，并在所有 Promise 都成功完成时返回一个新的 Promise，或者在其中任何一个 Promise 失败时立即返回失败的 Promise。

        function promiseAll(promises) {
            return new Promise(function(resolve, reject) {
                if(!Array.isArray(promises)) {
                    throw new TypeError(`argument must be a array`)
                }

                var resolvedCounter = 0;
                var promiseNum = promises.length;
                var resolvedResult = [];

                for (let i = 0; i < promiseNum; i++) {
                    Promise.resolve(promises[i]).then(value => {
                        resolvedCounter++;
                        resolvedResult[i] = value;
                        if (resolvedCounter == promiseNum) {
                            return resolve(resolvedResult)
                        }
                    }, error => {
                        return reject(error)
                    })
                }
            })
        }
        // test
        let p1 = new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(1)
            }, 1000)
        })

        let p2 = new Promise(function (resolve, reject) {
            setTimeout(function() {
                resolve(2)
            }, 2000)
        })

        let p3 = new Promise(function (resolve, reject) {
            setTimeout(function() {
                resolve(3)
            }, 3000)
        })

        promiseAll([p3, p1, p2]).then(res => {
            console.log(res) // [3, 1, 2]
        })



        // 7. 手写防抖
        // 在每个函数内部，无需声明就可以直接使用 arguments 对象。
        function debounce(fn, wait) {
            let timer = null;

            return function() {
                let context = this;
                let args = arguments;

                // 如果此时存在定时器的话，则取消之前的定时器重新计时
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }

                // 设置定时器，使事件间隔指定事件后执行
                timer = setTimeout(() => {
                    fn.apply(context, args);
                }, wait);
            };
        }


        // 8. 手写节流
        // 思路： 如果两次事件间隔超过了指定事件，则执行函数
        function throttle(fn, delay) {
            let curTime = Date.now();
            
            return function() {
                let context = this;
                let args = arguments;
                let nowTime = Date.now();

                if (nowTime - curTime >= delay) {
                    curTime = Date.now();
                    return fn.apply(context, args);
                }
            }
        }

        // 9.手写类型判断函数
        function getType(value) {
            // 判断数据是null的情况
            if (value == null) {
                return value + '';
            }

            // 判断数据是引用类型的情况
            // 每个对象都继承自 Object，因此都可以调用这个方法。当调用 Object.prototype.toString 方法时，它会返回一个格式为 [object Type] 的字符串，其中 Type 就是该对象的具体类型。
            // console.log(Object.prototype.toString.call([])); // 输出: [object Array]
            //console.log(Object.prototype.toString.call({})); // 输出: [object Object]
            //console.log(Object.prototype.toString.call(new Date())); // 输出: [object Date]
            //console.log(Object.prototype.toString.call(/abc/)); // 输出: [object RegExp]

            if (typeof value === 'object') {
                let valueClass = Object.prototype.toString.call(value);
                let type = valueClass.split(' ')[1].split('');
                // 先根据空格进行分割，分割完毕取右半部分，如Array],再以空字符串进行分割，即将字符都分割成单独字符,'A' 'r' 'r' 'a' 'y' ]
                type.pop();
                return type.join('').toLowerCase();
            } else {
                // 判断数据是基本数据类型的情况和函数的情况
                // 函数类型，typeof会返回function
                return typeof value;
            }
        }



        // 10. 手写call函数
        //  call函数的语法：function.call(thisArg, arg1, arg2,...)
        Function.prototype.myCall = function(context) {
            // 判断调用对象是否为函数
            if (typeof this !== 'function') {
                console.error('type error');
            }

            // 获取参数
            // slice(begin,end)返回从begin到end（左闭右开）
            // slice(1)返回从索引1到数组末尾，因为call方法的第一个参数不是args
            let args = [...arguments].slice(1);
            let result = null;

            // 判断context是否传入，如果未传入则设置为window
            context = context || window;

            // 在 JavaScript 中，对象是动态的，这意味着可以在运行时为对象添加、修改或删除属性和方法。对于一个普通对象，我们可以随时给它添加新的属性或方法，而不需要事先声明。本行直接为context添加fn属性。

            // 下面处理方法是为了模拟原生call方法改变函数内部this指向的核心功能，同时避免对上下文对象造成不必要的修改。

            // 将调用函数设为上下文对象的一个属性
            context.fn = this;
            // 使用上下文对象来调用这个方法，并保存返回结果
            result = context.fn(...args);
            // 删除刚才新增的属性
            delete context.fn;
            return result;
        }



        // 11. 手写apply函数
        // function.apply(thisArg, [argsArray])
        Function.prototype.myApply = function(context) {
            // 判断调用对象是否为函数
            if (typeof this !== 'function') {
                throw new TypeError('Error');
            }
            let result = null;

            // 判断context是否存在，如果未传入则为window
            context = context || window;
            // 将函数设为对象的方法
            context.fn = this;
            // 调用方法
            if (arguments[1]) {
                result = context.fn(...arguments[1]);
            } else {
                result = context.fn();
            }

            // 将属性删除
            delete context.fn;
            return result;
        }


        // 12. 手写bind函数
        // function.bind(thisArg[, arg1[, arg2[, ...]]])
        Function.prototype.myBind = function(context) {
            // 判断调用对象是否为函数
            if (typeof this !== 'function') {
                throw new TypeError('Error');
            }

            // 获取参数
            let args = [...arguments].slice(1);
            let fn = this;
            return function Fn() {
                // 根据调用方式，传入不同绑定值
                // 需要判断函数作为构造函数的情况，这个时候需要传入当前函数的this给apply调用，其余情况都传入指定的上下文对象。
                // concat方法主要用于合并多个数组、字符串
                return fn.apply(
                    this instanceof Fn ? this : context,
                    args.concat(...arguments)
                    // 把预设参数数组args和新函数调用时传递的参数合并成一个新的数组
                );
            };
        }


        // 13. 函数柯里化的实现
        // 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。
        
        function curry(fn) {
            // 实现了柯里化，将多参数函数转换为一系列单参数函数，直到收集到足够的参数后才执行原始函数。
            if (typeof fn !== 'function') {
                throw new Error('curry() require a function');
            }

            return function curried(...args) {
                if (args.length >= fn.length) {
                    return fn.apply(this, args);
                    // 检查当前收集到的参数数量是否已经满足原始函数 fn 的参数数量要求（fn.length 表示函数的参数个数）。如果参数数量足够，则调用原始函数 fn，并将收集到的参数通过 apply 方法传入。

                } else {
                    return function(...args2) {
                        return curried.apply(this, args.concat(args2));
                        // 如果当前参数数量不足，返回一个新的函数。这个新函数会继续收集参数 args2，并将之前收集的参数 args 和新参数 args2 合并后，继续调用 curried 函数。
                        // array.concat(value1, value2, ..., valueN) ，concat 是数组的一个方法，用于将多个数组或值连接成一个新的数组。它不会修改原数组，而是返回一个新的数组。
                    }
                }
            };
        }



        // 14. 实现浅拷贝
        // 浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。

        





        // 15. 实现深拷贝
        // 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用.


    </script>
</body>
</html>